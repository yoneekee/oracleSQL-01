
SELECT * FROM DEPT;
SELECT * FROM EMP;
SELECT * FROM SALGRADE;

SELECT * FROM DEPT, EMP ORDER BY EMPNO;
SELECT * FROM DEPT, EMP WHERE EMP.DEPTNO = DEPT.DEPTNO ORDER BY EMPNO;

--- JOIN
SELECT * FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO
ORDER BY EMPNO;

SELECT * FROM EMP e, DEPT d
WHERE e.DEPTNO = d.DEPTNO
ORDER BY EMPNO;

SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO 
ORDER BY D.DEPTNO, E.EMPNO;

SELECT E.EMPNO, E.ENAME, E.SAL, E.JOB,
D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND SAL >= 3000;

SELECT * FROM SALGRADE;

-- 비등가조인 (같은 값이 없음)
SELECT * FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

-- 같은 테이블 안에서 엮어내기
SELECT 
E1.EMPNO, E1.ENAME, E1.MGR,
E2.EMPNO AS MGR_EMPNO, 
E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;


---------------------
--- 외부조인

-- 왼쪽 외부 조인 / LEFT OUTER JOIN
SELECT 
E1.EMPNO, E1.ENAME, E1.MGR,
E2.EMPNO AS MGR_EMPNO,
E2.ENAME AS MGR_NAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+)
ORDER BY E1.EMPNO;

-- 오른쪽 외부 조인 / RIGHT OUTER JOIN
SELECT 
E1.EMPNO, E1.ENAME, E1.MGR,
E2.EMPNO AS MGR_EMPNO,
E2.ENAME AS MGR_NAME
FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO
ORDER BY E1.EMPNO;

SELECT COUNT(EMPNO) FROM EMP WHERE MGR IS NULL;
SELECT * FROM EMP;

-- NATURAL JOIN
-- 알아서 값이 같은 열을 찾는다
SELECT  
E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM,
DEPTNO, D.DNAME, D.LOC
FROM
EMP E NATURAL JOIN DEPT D
WHERE SAL >= 3000
ORDER BY DEPTNO, E.EMPNO;

-- JOIN / USING
-- 값이 같은 열을 명시한다
SELECT 
*
FROM EMP E JOIN DEPT D USING (DEPTNO) 
WHERE SAL >= 3000
ORDER BY DEPTNO, E.EMPNO;

-- JOIN / ON
SELECT * 
FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO)
WHERE SAL >= 3000
ORDER BY E.DEPTNO, EMPNO;

SELECT * 
FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO)
WHERE SAL <= 3000
ORDER BY E.DEPTNO, EMPNO;

-- 오라클 방식과 디폴트 방식 비교
--- LEFT OUTER JOIN 
SELECT 
E1.EMPNO, E1.ENAME, E1.MGR,
E2.EMPNO AS MGR_EMPNO,
E2.ENAME AS MGR_ENAME
FROM EMP E1 LEFT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;

SELECT 
E1.EMPNO, E1.ENAME, E1.MGR,
E2.EMPNO AS MGR_EMPNO,
E2.ENAME AS MGR_NAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+)
ORDER BY E1.EMPNO;

--- RIGHT OUTER JOIN 
SELECT 
E1.EMPNO, E1.ENAME, E1.MGR,
E2.EMPNO AS MGR_EMPNO,
E2.ENAME AS MGR_ENAME
FROM EMP E1 RIGHT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;

SELECT 
E1.EMPNO, E1.ENAME, E1.MGR,
E2.EMPNO AS MGR_EMPNO,
E2.ENAME AS MGR_NAME
FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO
ORDER BY E1.EMPNO;

-- 전체 외부 조인
--- 오라클 (+)로는 전체 외부 조인을 사용할 수 없다 
SELECT 
E1.EMPNO, E1.ENAME, E1.MGR,
E2.EMPNO AS MGR_EMPNO,
E2.ENAME AS MGR_ENAME
FROM EMP E1 FULL OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;


------ 문제

-- 1
SELECT D.DEPTNO, D.DNAME,
E.EMPNO, E.ENAME, E.SAL
FROM DEPT D JOIN EMP E ON D.DEPTNO = E.DEPTNO
WHERE E.SAL >= 2000;

-- 2
SELECT D.DEPTNO, D.DNAME,
TRUNC(AVG(E.SAL)) AS AVG_SAL, 
MAX(E.SAL) AS MAX_SAL, 
MIN(E.SAL) AS MIN_SAL,
COUNT(*) AS CNT 
FROM DEPT D JOIN EMP E ON D.DEPTNO = E.DEPTNO
GROUP BY D.DEPTNO, D.DNAME;

-- 3
SELECT 
D.DEPTNO, D.DNAME,
E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM DEPT D JOIN EMP E
ON D.DEPTNO = E.DEPTNO
ORDER BY D.DEPTNO, E.ENAME;

-- 4
SELECT
D.DEPTNO, D.DNAME, 
E1.EMPNO, E1.ENAME, E1.MGR, E1.SAL, E1.DEPTNO, 
LOSAL, HISAL, GRADE, 
E2.EMPNO AS MGR_EMPNO, 
E2.ENAME AS MGR_ENAME
FROM DEPT D, EMP E1, EMP E2, SALGRADE S
WHERE 
D.DEPTNO = E1.DEPTNO(+) 
AND E1.MGR = E2.EMPNO(+) 
AND E1.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
ORDER BY D.DEPTNO, EMPNO;

SELECT
D.DEPTNO, D.DNAME, E1.EMPNO, E1.ENAME, E1.MGR, E1.SAL,
E1.DEPTNO, LOSAL, HISAL, GRADE, 
E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM
EMP E1 FULL OUTER JOIN EMP E2 ON (E2.EMPNO = E1.MGR)
RIGHT OUTER JOIN DEPT D ON (D.DEPTNO = E1.DEPTNO)
FULL OUTER JOIN SALGRADE S ON (E1.SAL BETWEEN S.LOSAL AND S.HISAL)
ORDER BY D.DEPTNO, EMPNO;